require 'rake/clean'
require 'active_support/core_ext/date'
require 'faraday_middleware/aws_signers_v4'
require 'elasticsearch'

# TODO - put this somewhere else?
MAILDIRS = %w{ inbound uvlist wp_posts wp_dailyuv }
ADAPT_FILE = 'adapt.sql'

desc 'Refresh database from production data'
task :refresh_database do
  %w{ kill_delayed_jobs
      move_mail
      transfer_database_data
      run_migrations
      reindex
      restart_front_end
      start_delayed_jobs
      publish_latest_import }.each do |task|
    invoke "refresh_database:#{task}"
  end
end

namespace :refresh_database do
  def app_server_roles
    fetch(:app_server_role, :app)
  end

  def get_adapt_template
    File.read(File.expand_path(File.join(File.dirname(__FILE__), '..', '..', '..', 'config', 'adapt.rq')))
  end

  desc 'Kill running delayed jobs'
  task :kill_delayed_jobs do
    on roles(app_server_roles) do
      execute ". /etc/profile && cd #{deploy_to}/current && RAILS_ENV=production bin/delayed_job stop"
    end
  end

  desc 'Writes adapt.sql file for transforming the database to work for the new environment'
  task :write_adapt_sql do
    File.open(ADAPT_FILE, 'w') do |f|
      f.write(get_adapt_template % {dsp_endpoint_hostname: fetch(:dsp_endpoint_hostname),
                                    site_endpoint: fetch(:site_endpoint)})
    end
    CLEAN.include(ADAPT_FILE)
  end

  desc 'Move mail from /new to /cur'
  task :move_mail do
    on roles(app_server_roles) do
      MAILDIRS.each do |mdir|
        execute "mv /var/mail/#{mdir}/new/* /var/mail/#{mdir}/cur || :"
      end
    end
  end

  desc 'Transfer database data from prod'
  task :transfer_database_data => :write_adapt_sql do
    if ENV.has_key?('SOURCE_DATABASE_USERNAME')
      set(:source_database_username, ENV['SOURCE_DATABASE_USERNAME'])
    else
      ask(:source_database_username, 'knotweed')
    end
    if ENV.has_key?('SOURCE_DATABASE_PASSWORD')
      set(:source_database_password, ENV['SOURCE_DATABASE_PASSWORD'])
    else
      ask(:source_database_password, nil)
    end
    if ENV.has_key?('DEST_DATABASE_USERNAME')
      set(:dest_database_username, ENV['DEST_DATABASE_USERNAME'])
    else
      ask(:dest_database_username, 'knotweed')
    end
    if ENV.has_key?('DEST_DATABASE_PASSWORD')
      set(:dest_database_password, ENV['DEST_DATABASE_PASSWORD'])
    else
      ask(:dest_database_password, nil)
    end
    # TODO - this should only execute on one server
    on roles(app_server_roles) do
      execute "PGPASSWORD=\"#{fetch(:source_database_password)}\" pg_dump -c --if-exists -x -U #{fetch(:source_database_username)} -h #{fetch(:source_database_host)} #{fetch(:source_database)} | " \
              "PGPASSWORD=\"#{fetch(:dest_database_password)}\" psql -U #{fetch(:dest_database_username)} -h #{fetch(:dest_database_host)} -f - #{fetch(:dest_database)}"

      upload! ADAPT_FILE, '/tmp/adapt.sql'
      execute "PGPASSWORD=\"#{fetch(:dest_database_password)}\" psql -U #{fetch(:dest_database_username)} -h #{fetch(:dest_database_host)} #{fetch(:dest_database)} -f /tmp/adapt.sql"
    end
  end

  desc 'Run rails database migrations'
  task :run_migrations do
    on roles(app_server_roles) do
      execute ". /etc/profile && cd #{deploy_to}/current && RAILS_ENV=production bundle exec rake db:migrate"
    end
  end

  desc 'Restore elasticsearch index'
  task :reindex do
    source_es =
      Elasticsearch::Client.new(
      url: fetch(:source_es_url),
      transport_options: {request: {timeout: 900}},
      retry_on_failure: true # https://github.com/ankane/searchkick/issues/351
    ) do |f|
      f.request :aws_signers_v4, {
                  credentials: Aws::Credentials.new(ENV["AWS_ACCESS_KEY_ID"], ENV["AWS_SECRET_ACCESS_KEY"]),
                  service_name: "es",
                  region: "us-east-1"
                }
    end
    dest_es =
      Elasticsearch::Client.new(
      url: fetch(:dest_es_url),
      transport_options: {request: {timeout: 900}},
      retry_on_failure: true # https://github.com/ankane/searchkick/issues/351
    ) do |f|
      f.request :aws_signers_v4, {
                  credentials: Aws::Credentials.new(ENV["AWS_ACCESS_KEY_ID"], ENV["AWS_SECRET_ACCESS_KEY"]),
                  service_name: "es",
                  region: "us-east-1"
                }
    end

    snapshot_name = "refresh-#{Time.new.to_i}"

    puts "creating snapshot #{snapshot_name}"
    source_es.snapshot.create repository: fetch(:es_repository), snapshot: snapshot_name, wait_for_completion: true
    puts "deleting existing indices"
    # AWS doesn't support closing
    dest_es.indices.delete index: dest_es.indices.get_aliases.keys
    puts "restoring snapshot #{snapshot_name}"
    dest_es.snapshot.restore repository: fetch(:es_repository), snapshot: snapshot_name
  end

  desc 'Restart ember front-end'
  task :restart_front_end do
    on roles(app_server_roles) do
      execute 'touch /var/www/knotweed-ember/current/tmp/restart.txt'
    end
  end

  desc 'Start delayed jobs'
  task :start_delayed_jobs do
    on roles(app_server_roles) do
      execute ". /etc/profile && cd #{deploy_to}/current && RAILS_ENV=production bin/delayed_job -n 4 restart"
    end
  end

  desc 'Publish latest import'
  task :publish_latest_import do
    pub_start_date = ENV['PUBSTARTDATE'] ? ENV['PUBSTARTDATE'] : Date.current.prev_day.to_s
    on roles(app_server_roles) do
      execute ". /etc/profile && cd #{deploy_to}/current && PUBSTARTDATE=#{pub_start_date} RAILS_ENV=production bundle exec rake backpublish"
    end
  end
end
